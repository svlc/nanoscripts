#! /usr/bin/env python

import sys, os
import unicodedata
import re

def usage(opts):
	# join short and long options into one string
	opt_ls = [ ', '.join(rec) for rec in opts ]
	size = len(max(opt_ls, key=len))

	print("Normalize name(s) of file(s), interactively asking about all of them.",
		  "Usage: " + os.path.basename(__file__) + " [OPTION] FILE1 [FILE2 ...]",
		  sep='\n')
	for rec, val in opts.items():
		print(("  {0:" + str(size + 2) + "s}{1:s}")
			  .format(', '.join(rec), val['help']))

def get_confirmation():

	print("Proceed with the operation? [y/n] ", end='')
	ret = input()
	if ret != 'y':
		raise Exception('Did not read "y". Skipping the file.')

def check_file_existence(file):

	if not os.path.exists(file):
		raise Exception('File "' + file + '" does not exist.')

def get_opt_record(opts, opt):
	for rec in opts:
		if opt in rec:
			return rec
	return None

def parse_argv(argv, opts):

	# generate all "short optarg, option presence count" dictionary pairs
	opts_occur = dict()
	for rec, val in opts.items():
		opts_occur[rec[0]] = val['cnt']

	opt_end_idx = 1
	for arg in argv:
		# if option is not recognized
		rec = get_opt_record(opts, arg)
		if rec == None:
			if arg == '--':
				first_file_pos += 1
			# if argument starts with minus
			elif arg[0] == '-':
				raise Exception("Option '" + arg + "' is invalid.")
			break
		elif opts_occur[rec[0]] >= 1:
			raise Exception("Option '" + arg + "' occures more then once.")
		else:
			opts_occur[rec[0]] += 1
			opt_end_idx += 1

	if opts_occur['-d'] and opts_occur['-u'] and opts_occur['-s'] and opts_occur['-w']:
		raise Exception("All functionality got turned off by the options.")

	return opts_occur, opt_end_idx

def refine_file_name(path, opts):

	check_file_existence(path)
	# remove trailing slash if present
	path = os.path.normpath(path)
	name = orig_name = os.path.basename(path)
	dir_path = os.path.dirname(path)

	if opts['-d'] == 0:
		name = ''.join(c for c in unicodedata.normalize('NFD', name)
					   if unicodedata.category(c) != 'Mn')
	if opts['-u'] == 0:
		name = name.lower()
	if opts['-s'] == 0:
		name = name.strip()
		name = re.sub('\s+', ' ', name)
	if opts['-w'] == 0:
		name = re.sub('\s', '.', name)

	new_path = os.path.join(dir_path, name)
	if name == orig_name:
		raise Exception('"' + path + '": Nothing to refine. Skipping the file.')
	elif os.path.exists(new_path):
		raise Exception('Destination file name "' + new_path +
						'" already exists. Skipping the file.')
	else:
		print('"', path, '" ::: "', new_path, '". ', sep='', end='')
	if not opts['-f']:
		get_confirmation()
	print('Done.', file=sys.stderr, flush=True)
	os.rename(path, new_path)
	return new_path

def main():

	opts = {
		("-d",): { 'help': "disable diacritics removal", 'cnt': 0 },
		("-u",): { 'help': "disable uppercase to lowercase transformation ", 'cnt': 0 },
		("-s",): { 'help': "disable stripping of leading/trailling whitespace "
				   + "and removal of redundant whitespace occurences", 'cnt': 0 },
		("-w",): { 'help': "disable substitution of whitespace for dots", 'cnt': 0 },
		("-r", "--recursive"): { 'help': "enable recursive directory processing", 'cnt': 0 },
		("-f", "--force"): { 'help':  "force non-interactive mode", 'cnt': 0 },
	}

	if len(sys.argv) == 1:
		usage(opts)
		return 1
	if len(sys.argv) == 2 and (sys.argv[1] == "-h" or sys.argv[1] == "--help"):
		usage()
		return 0

	try:
		opts_occur, opt_end_idx = parse_argv(sys.argv[1:], opts)
	except Exception as msg:
			print(msg, file=sys.stderr)
			return 2

	ret = 0
	files = []
	open_dirs = []
	rel_path = "."
	for name in sys.argv[opt_end_idx:]:
		if os.path.isdir(name):
			open_dirs.append(name)
		else:
			files.append(name)

	while True:
		# refine all non-directory names
		while files:
			try:
				path = files.pop(0)
				refine_file_name(path, opts_occur)
			except Exception as msg:
				print(msg, file=sys.stderr, flush=True)
				ret = 3

		# refine all directory names
		for idx, dir in enumerate(open_dirs):
			try:
				open_dirs[idx] = refine_file_name(dir, opts_occur)
			except Exception as msg:
				print(msg, file=sys.stderr, flush=True)
				ret = 3

		if opts_occur['-r'] and open_dirs:
				dir_path = open_dirs.pop(0)
				for name in sorted(os.listdir(dir_path)):
					path = os.path.join(dir_path, name)
					if os.path.isdir(path):
						open_dirs.append(path)
					else:
						files.append(path)
		else:
			break

	return ret

ret = main()
sys.exit(ret)
